"""
Invoice Service - Business logic for invoice operations
Real PostgreSQL database integration
"""

import logging
from typing import List, Dict, Optional
from decimal import Decimal


class InvoiceService:
    """Service for invoice operations"""

    def __init__(self, config):
        self.config = config
        self.logger = logging.getLogger(__name__)

        # Try to initialize PostgreSQL client
        self.db_client = None
        self._init_database()

    def _init_database(self):
        """Initialize database connection"""
        try:
            from database.postgres_client import PostgresClient
            self.db_client = PostgresClient(self.config)

            # Test connection
            if self.db_client.test_connection():
                self.logger.info("PostgreSQL client initialized and connected")
            else:
                self.logger.warning("PostgreSQL connection test failed - using stub data")
                self.db_client = None

        except ImportError:
            self.logger.warning(
                "psycopg3 not installed - using stub data. "
                "Install with: pip install 'psycopg[binary,pool]'"
            )
        except Exception as e:
            self.logger.error(f"Failed to initialize database: {e}")
            self.logger.warning("Using stub data")
            self.db_client = None

    def get_pending_invoices(self) -> List[Dict]:
        """
        Get list of pending invoices

        Returns:
            List of invoice dictionaries
        """
        if self.db_client:
            try:
                return self._get_invoices_from_database()
            except Exception as e:
                self.logger.error(f"Database query failed: {e}")
                self.logger.warning("Falling back to stub data")

        return self._get_stub_invoices()

    def _get_invoices_from_database(self) -> List[Dict]:
        """Get invoices from PostgreSQL"""
        query = """
            SELECT 
                id,
                invoice_number,
                invoice_date::text as invoice_date,
                supplier_name,
                supplier_ico,
                total_amount,
                currency,
                status
            FROM invoices_pending
            WHERE status = 'pending'
            ORDER BY invoice_date DESC, id DESC
        """

        results = self.db_client.execute_query(query)
        self.logger.info(f"Loaded {len(results)} pending invoices from database")

        return results

    def _get_stub_invoices(self) -> List[Dict]:
        """Get stub invoice data for testing"""
        self.logger.info("Using stub invoice data")

        return [
            {
                'id': 1,
                'invoice_number': 'FAV-2025-001',
                'invoice_date': '2025-11-12',
                'supplier_name': 'Test Dodávateľ s.r.o.',
                'supplier_ico': '12345678',
                'total_amount': Decimal('1200.00'),
                'currency': 'EUR',
                'status': 'pending'
            },
            {
                'id': 2,
                'invoice_number': 'FAV-2025-002',
                'invoice_date': '2025-11-11',
                'supplier_name': 'Iný Dodávateľ a.s.',
                'supplier_ico': '87654321',
                'total_amount': Decimal('850.50'),
                'currency': 'EUR',
                'status': 'pending'
            },
            {
                'id': 3,
                'invoice_number': 'FAV-2025-003',
                'invoice_date': '2025-11-10',
                'supplier_name': 'ABC Trading s.r.o.',
                'supplier_ico': '11223344',
                'total_amount': Decimal('2450.75'),
                'currency': 'EUR',
                'status': 'pending'
            },
            {
                'id': 4,
                'invoice_number': 'FAV-2025-004',
                'invoice_date': '2025-11-09',
                'supplier_name': 'XYZ Company a.s.',
                'supplier_ico': '55667788',
                'total_amount': Decimal('675.25'),
                'currency': 'EUR',
                'status': 'pending'
            },
            {
                'id': 5,
                'invoice_number': 'FAV-2025-005',
                'invoice_date': '2025-11-08',
                'supplier_name': 'Slovak Suppliers s.r.o.',
                'supplier_ico': '99887766',
                'total_amount': Decimal('3125.00'),
                'currency': 'EUR',
                'status': 'pending'
            }
        ]

    def get_invoice_by_id(self, invoice_id: int) -> Optional[Dict]:
        """
        Get single invoice by ID

        Args:
            invoice_id: Invoice ID

        Returns:
            Invoice dictionary or None
        """
        if self.db_client:
            try:
                query = """
                    SELECT 
                        id,
                        invoice_number,
                        invoice_date::text as invoice_date,
                        supplier_name,
                        supplier_ico,
                        total_amount,
                        currency,
                        status
                    FROM invoices_pending
                    WHERE id = %s
                """
                results = self.db_client.execute_query(query, (invoice_id,))

                if results:
                    self.logger.info(f"Loaded invoice {invoice_id} from database")
                    return results[0]
                else:
                    self.logger.warning(f"Invoice {invoice_id} not found in database")
                    return None

            except Exception as e:
                self.logger.error(f"Failed to load invoice {invoice_id}: {e}")

        # Fallback to stub data
        invoices = self._get_stub_invoices()
        for invoice in invoices:
            if invoice['id'] == invoice_id:
                return invoice
        return None

    def get_invoice_items(self, invoice_id: int) -> List[Dict]:
        """
        Get invoice line items

        Args:
            invoice_id: Invoice ID

        Returns:
            List of item dictionaries
        """
        if self.db_client:
            try:
                return self._get_items_from_database(invoice_id)
            except Exception as e:
                self.logger.error(f"Database query failed: {e}")
                self.logger.warning("Falling back to stub data")

        return self._get_stub_items(invoice_id)

    def _get_items_from_database(self, invoice_id: int) -> List[Dict]:
        """Get items from PostgreSQL"""
        query = """
            SELECT 
                id,
                invoice_id,
                plu_code,
                item_name,
                category_code,
                unit,
                quantity,
                unit_price,
                rabat_percent,
                price_after_rabat,
                total_price
            FROM invoice_items_pending
            WHERE invoice_id = %s
            ORDER BY id
        """

        results = self.db_client.execute_query(query, (invoice_id,))
        self.logger.info(f"Loaded {len(results)} items for invoice {invoice_id} from database")

        return results

    def _get_stub_items(self, invoice_id: int) -> List[Dict]:
        """Get stub item data for testing"""
        self.logger.info(f"Using stub items for invoice {invoice_id}")

        # Different items per invoice
        if invoice_id == 1:
            return [
                {
                    'id': 1,
                    'invoice_id': 1,
                    'plu_code': '1001',
                    'item_name': 'Produkt A',
                    'category_code': '01',
                    'unit': 'ks',
                    'quantity': Decimal('10.000'),
                    'unit_price': Decimal('15.00'),
                    'rabat_percent': Decimal('10.0'),
                    'price_after_rabat': Decimal('13.50'),
                    'total_price': Decimal('135.00')
                },
                {
                    'id': 2,
                    'invoice_id': 1,
                    'plu_code': '1002',
                    'item_name': 'Produkt B',
                    'category_code': '02',
                    'unit': 'ks',
                    'quantity': Decimal('5.000'),
                    'unit_price': Decimal('25.00'),
                    'rabat_percent': Decimal('5.0'),
                    'price_after_rabat': Decimal('23.75'),
                    'total_price': Decimal('118.75')
                }
            ]
        elif invoice_id == 2:
            return [
                {
                    'id': 3,
                    'invoice_id': 2,
                    'plu_code': '2001',
                    'item_name': 'Tovar X',
                    'category_code': '03',
                    'unit': 'kg',
                    'quantity': Decimal('20.500'),
                    'unit_price': Decimal('12.50'),
                    'rabat_percent': Decimal('15.0'),
                    'price_after_rabat': Decimal('10.63'),
                    'total_price': Decimal('217.92')
                }
            ]
        else:
            # Default items for other invoices
            return [
                {
                    'id': 100 + invoice_id,
                    'invoice_id': invoice_id,
                    'plu_code': f'{1000 + invoice_id}',
                    'item_name': f'Test položka {invoice_id}',
                    'category_code': '01',
                    'unit': 'ks',
                    'quantity': Decimal('1.000'),
                    'unit_price': Decimal('100.00'),
                    'rabat_percent': Decimal('0.0'),
                    'price_after_rabat': Decimal('100.00'),
                    'total_price': Decimal('100.00')
                }
            ]

    def save_invoice(self, invoice_id: int, items: List[Dict]) -> bool:
        """
        Save invoice items

        Args:
            invoice_id: Invoice ID
            items: List of item dictionaries

        Returns:
            True if saved successfully
        """
        try:
            self.logger.info(f"Saving invoice {invoice_id} with {len(items)} items")

            if self.db_client:
                return self._save_to_database(invoice_id, items)
            else:
                # Stub mode - just log
                self.logger.warning("Database not available - changes not saved (stub mode)")
                self.logger.info(f"Would save {len(items)} items:")
                for item in items:
                    self.logger.info(f"  - {item['item_name']}: {item['total_price']}")
                return True

        except Exception as e:
            self.logger.exception(f"Failed to save invoice {invoice_id}")
            return False

    def _save_to_database(self, invoice_id: int, items: List[Dict]) -> bool:
        """Save items to PostgreSQL"""
        try:
            with self.db_client.transaction() as conn:
                with conn.cursor() as cur:
                    # Update each item
                    update_query = """
                        UPDATE invoice_items_pending
                        SET 
                            item_name = %s,
                            category_code = %s,
                            unit = %s,
                            quantity = %s,
                            unit_price = %s,
                            rabat_percent = %s,
                            price_after_rabat = %s,
                            total_price = %s,
                            updated_at = CURRENT_TIMESTAMP
                        WHERE id = %s AND invoice_id = %s
                    """

                    for item in items:
                        params = (
                            item['item_name'],
                            item['category_code'],
                            item['unit'],
                            item['quantity'],
                            item['unit_price'],
                            item['rabat_percent'],
                            item['price_after_rabat'],
                            item['total_price'],
                            item['id'],
                            invoice_id
                        )
                        cur.execute(update_query, params)

                    # Update invoice total
                    total_query = """
                        UPDATE invoices_pending
                        SET 
                            total_amount = (
                                SELECT SUM(total_price)
                                FROM invoice_items_pending
                                WHERE invoice_id = %s
                            ),
                            updated_at = CURRENT_TIMESTAMP
                        WHERE id = %s
                    """
                    cur.execute(total_query, (invoice_id, invoice_id))

            self.logger.info(f"Successfully saved {len(items)} items to database")
            return True

        except Exception as e:
            self.logger.exception("Database save failed")
            return False

    def calculate_item_price(self, unit_price: Decimal, rabat_percent: Decimal, 
                            quantity: Decimal) -> tuple:
        """
        Calculate item prices

        Args:
            unit_price: Unit price
            rabat_percent: Rabat percentage (0-100)
            quantity: Quantity

        Returns:
            Tuple (price_after_rabat, total_price)
        """
        price_after_rabat = unit_price * (Decimal('1') - rabat_percent / Decimal('100'))
        price_after_rabat = price_after_rabat.quantize(Decimal('0.01'))

        total_price = price_after_rabat * quantity
        total_price = total_price.quantize(Decimal('0.01'))

        return (price_after_rabat, total_price)
