#!/usr/bin/env python
"""
Customer-specific deployment script
Usage: python deploy/deploy.py --customer magerstav [--dry-run]
"""

import argparse
import fnmatch
from pathlib import Path

import yaml


class CustomerDeployer:
    """Deploy files filtered by customer configuration"""

    def __init__(self, customer: str, source_dir: Path, dry_run: bool = False):
        self.customer = customer
        self.source_dir = source_dir
        self.dry_run = dry_run
        self.config_dir = source_dir / "deploy" / "config"

        # Load configs
        self.base_config = self._load_config("base.yaml")
        self.customer_config = self._load_config(f"{customer}.yaml")

        # Merge exclude patterns
        self.exclude_patterns = set(self.base_config.get("exclude", []))
        self.exclude_patterns.update(self.customer_config.get("exclude", []))

        # Merge include patterns
        self.include_patterns = set(self.base_config.get("include", []))
        self.include_patterns.update(self.customer_config.get("include", []))

        self.deploy_path = Path(
            self.customer_config.get("deploy_path", "C:\\Deployment\\nex-automat")
        )

    def _load_config(self, filename: str) -> dict:
        """Load YAML config file"""
        config_path = self.config_dir / filename
        if not config_path.exists():
            raise FileNotFoundError(f"Config not found: {config_path}")

        with open(config_path, encoding="utf-8") as f:
            return yaml.safe_load(f) or {}

    def _should_exclude(self, rel_path: str) -> bool:
        """Check if path matches any exclude pattern"""
        path_parts = Path(rel_path).parts

        for pattern in self.exclude_patterns:
            # Check full path
            if fnmatch.fnmatch(rel_path, pattern):
                return True
            if fnmatch.fnmatch(rel_path, f"*/{pattern}"):
                return True

            # Check each part of path
            for part in path_parts:
                if fnmatch.fnmatch(part, pattern):
                    return True
                if fnmatch.fnmatch(part, pattern.rstrip("/")):
                    return True

        return False

    def _should_include(self, rel_path: str) -> bool:
        """Check if path is in include list"""
        for pattern in self.include_patterns:
            pattern_clean = pattern.rstrip("/")
            if rel_path.startswith(pattern_clean):
                return True
            if fnmatch.fnmatch(rel_path, pattern):
                return True
        return False

    def get_files_to_deploy(self) -> list[Path]:
        """Get list of files to deploy"""
        files = []

        for file_path in self.source_dir.rglob("*"):
            if not file_path.is_file():
                continue

            rel_path = file_path.relative_to(self.source_dir).as_posix()

            # Skip if excluded
            if self._should_exclude(rel_path):
                continue

            # Include if in include list
            if self._should_include(rel_path):
                files.append(file_path)

        return sorted(files)

    def print_summary(self, files: list[Path]):
        """Print deployment summary"""
        print(f"\n{'=' * 60}")
        print(f"DEPLOYMENT SUMMARY - {self.customer.upper()}")
        print(f"{'=' * 60}")
        print(f"Source: {self.source_dir}")
        print(f"Target: {self.deploy_path}")
        print(f"Files:  {len(files)}")
        print(f"{'=' * 60}\n")

        # Group by top-level directory
        by_dir = {}
        for f in files:
            rel = f.relative_to(self.source_dir)
            top_dir = rel.parts[0] if len(rel.parts) > 1 else "/"
            by_dir.setdefault(top_dir, []).append(f)

        for dir_name, dir_files in sorted(by_dir.items()):
            print(f"  {dir_name}/: {len(dir_files)} files")

    def create_manifest(self, files: list[Path], output_path: Path):
        """Create manifest file listing all deployed files"""
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(f"# Deployment manifest for {self.customer}\n")
            f.write("# Generated by deploy.py\n\n")
            for file in files:
                rel = file.relative_to(self.source_dir).as_posix()
                f.write(f"{rel}\n")
        print(f"âœ… Manifest: {output_path}")

    def deploy(self):
        """Execute deployment"""
        files = self.get_files_to_deploy()
        self.print_summary(files)

        if self.dry_run:
            print("ðŸ” DRY RUN - no files copied\n")
            print("Files to deploy:")
            for f in files[:50]:  # Show first 50
                print(f"  {f.relative_to(self.source_dir)}")
            if len(files) > 50:
                print(f"  ... and {len(files) - 50} more")
            return

        # Create manifest
        manifest_path = self.source_dir / "deploy" / f"manifest_{self.customer}.txt"
        self.create_manifest(files, manifest_path)

        print(f"\nðŸ“¦ Ready to deploy {len(files)} files to {self.deploy_path}")
        print("Use 'git pull' on target server to sync.\n")


def main():
    parser = argparse.ArgumentParser(description="Customer-specific deployment")
    parser.add_argument(
        "--customer",
        "-c",
        required=True,
        choices=["magerstav", "andros"],
        help="Customer name",
    )
    parser.add_argument(
        "--dry-run",
        "-n",
        action="store_true",
        help="Show what would be deployed without copying",
    )
    parser.add_argument(
        "--source",
        "-s",
        type=Path,
        default=Path(__file__).parent.parent,
        help="Source directory (default: project root)",
    )

    args = parser.parse_args()

    deployer = CustomerDeployer(
        customer=args.customer, source_dir=args.source.resolve(), dry_run=args.dry_run
    )

    deployer.deploy()


if __name__ == "__main__":
    main()
